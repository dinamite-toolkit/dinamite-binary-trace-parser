# Trace parsing framework

## Building

To build this, you must set `$INST_LIB` to point to the location of your `binaryinstrumentation.h` file and then run `make`. For example, assuming your DINAMITE LLVM pass lives in the $DINAMITE directory:

    INST_LIB=$DINAMITE/dinamite/library make

## Using

The build will produce a binary called `trace_parser`. If you run it without the arguments, it will print the list of available plugins. For example if you just want to print the binary trace generated by running a test in the $DINAMITE directory, you run the trace parser as follows:

    ./trace_parser -p print -m $DINAMITE $DINAMITE/trace.bin

The `-m` argument points to the location of the map files that map numbers to variables and function names. These files are generated when the program is compiled with the [DINAMITE compiler](https://bitbucket.org/datamancers/dinamite).

## Adding new plugins

In order to add a new plugin and register it with the tool, you need to add a new header file in `src/`.
The header file should include `traceplugin.h` and contain a class definition for the new plugin that inherits TracePlugin.

The general template should look something like this:

```
#include "traceplugin.h"

class NewPlugin : TracePlugin {
    public:
        PrintPlugin() : TracePlugin("plugin_name") { // change plugin_name into whatever you want to use to invoke your plugin
        }

        void processLog(logentry *log) {
            // your processing code goes here
        }

        void finalize() {
            // this gets called when we go through the entire log file
        }

        void passArgs(char *args) {

        }

};

static NewPlugin registerMyPlugin;  // this line is necessary for registering the plugin properly.

```

You also need to include the new header file in `main.cpp` for it to get built.

## Name maps

Our LLVM instrumentation tool emits JSON files with dictionaries that map numerical IDs to strings, used when tagging logs with variable, file, function and type names. This trace parser supports loading those maps and using them directly in any new plugin.

Your plugin will inherit the property `NameMaps *nmaps` from the `TracePlugin` base class. `NameMaps` provides the following functions each returning a **pointer** to std::string containing the name (to avoid needless copying on each read log):

```
string *getVariable(int idx)
string *getType(int idx)
string *getFile(int idx)
string *getFunction(int idx)

```

To properly load the maps, put the JSON files in the same directory and pass the path to it to the `-m` option parameter when running the tool.

## Plugin arguments

You can use `-a <argument_string>` option to pass arguments to the invoked plugin. This is used for setting up parameters, and your plugin should handle the behaviour in the `void passArgs(char *)` method.

If your argument string has spaces in it, you must wrap it in quotes (`"arg string"`)
